import Deque from "double-ended-queue";
import type { RunnableConfig } from "@langchain/core/runnables";
import type { CallbackManagerForChainRun } from "@langchain/core/callbacks/manager";
import { BaseCheckpointSaver, Checkpoint, PendingWrite, CheckpointPendingWrite, CheckpointMetadata, All } from "@langchain/langgraph-checkpoint";
import { BaseChannel } from "../channels/base.js";
import { PregelExecutableTask, PregelInterface, StreamMode } from "./types.js";
export type PregelLoopInitializeParams = {
    input?: any;
    config: RunnableConfig;
    checkpointer?: BaseCheckpointSaver;
    graph: PregelInterface<any, any>;
    onBackgroundError: (e: Error) => void;
};
type PregelLoopParams = {
    input?: any;
    config: RunnableConfig;
    checkpointer?: BaseCheckpointSaver;
    graph: PregelInterface<any, any>;
    checkpoint: Checkpoint;
    checkpointMetadata: CheckpointMetadata;
    checkpointPreviousVersions: Record<string, string | number>;
    checkpointPendingWrites: CheckpointPendingWrite[];
    checkpointConfig: RunnableConfig;
    channels: Record<string, BaseChannel>;
    step: number;
    stop: number;
    onBackgroundError: (e: Error) => void;
};
export declare class PregelLoop {
    protected input?: any;
    config: RunnableConfig;
    protected checkpointer?: BaseCheckpointSaver;
    protected checkpointerGetNextVersion: (current: number | undefined, channel: BaseChannel) => number;
    protected graph: PregelInterface<any, any>;
    channels: Record<string, BaseChannel>;
    protected checkpoint: Checkpoint;
    protected checkpointConfig: RunnableConfig;
    checkpointMetadata: CheckpointMetadata;
    protected checkpointPendingWrites: CheckpointPendingWrite[];
    protected checkpointPreviousVersions: Record<string, string | number>;
    step: number;
    protected stop: number;
    status: "pending" | "done" | "interrupt_before" | "interrupt_after" | "out_of_steps";
    tasks: PregelExecutableTask<any, any>[];
    stream: Deque<[StreamMode, any]>;
    protected isNested: boolean;
    protected _putCheckpointPromise: Promise<unknown>;
    onBackgroundError: (e: Error) => void;
    get backgroundTasksPromise(): Promise<unknown>;
    constructor(params: PregelLoopParams);
    static initialize(params: PregelLoopInitializeParams): Promise<PregelLoop>;
    protected _checkpointerPutAfterPrevious(input: {
        config: RunnableConfig;
        checkpoint: Checkpoint;
        metadata: CheckpointMetadata;
        newVersions: Record<string, string | number>;
    }): Promise<void>;
    /**
     * Put writes for a task, to be read by the next tick.
     * @param taskId
     * @param writes
     */
    putWrites(taskId: string, writes: PendingWrite<string>[]): void;
    /**
     * Execute a single iteration of the Pregel loop.
     * Returns true if more iterations are needed.
     * @param params
     */
    tick(params: {
        outputKeys: string | string[];
        interruptAfter: string[] | All;
        interruptBefore: string[] | All;
        manager?: CallbackManagerForChainRun;
    }): Promise<boolean>;
    /**
     * Resuming from previous checkpoint requires
     * - finding a previous checkpoint
     * - receiving None input (outer graph) or RESUMING flag (subgraph)
     */
    protected _first(): Promise<void>;
    protected _putCheckpoint(inputMetadata: Omit<CheckpointMetadata, "step">): Promise<void>;
}
export {};
