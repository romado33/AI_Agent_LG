"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printStepWrites = exports.printStepTasks = exports.printStepCheckpoint = exports.tasksWithWrites = exports.mapDebugCheckpoint = exports.mapDebugTaskResults = exports.mapDebugTasks = exports.printCheckpoint = void 0;
const langgraph_checkpoint_1 = require("@langchain/langgraph-checkpoint");
const constants_js_1 = require("../constants.cjs");
const errors_js_1 = require("../errors.cjs");
const io_js_1 = require("./io.cjs");
const utils_js_1 = require("./utils.cjs");
const COLORS_MAP = {
    blue: {
        start: "\x1b[34m",
        end: "\x1b[0m",
    },
    green: {
        start: "\x1b[32m",
        end: "\x1b[0m",
    },
    yellow: {
        start: "\x1b[33;1m",
        end: "\x1b[0m",
    },
};
/**
 * Wrap some text in a color for printing to the console.
 */
const wrap = (color, text) => `${color.start}${text}${color.end}`;
function printCheckpoint(step, channels) {
    console.log([
        `${wrap(COLORS_MAP.blue, "[langgraph/checkpoint]")}`,
        `Finishing step ${step}. Channel values:\n`,
        `\n${JSON.stringify(Object.fromEntries(_readChannels(channels)), null, 2)}`,
    ].join(""));
}
exports.printCheckpoint = printCheckpoint;
function* _readChannels(channels
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    for (const [name, channel] of Object.entries(channels)) {
        try {
            yield [name, channel.get()];
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            if (error.name === errors_js_1.EmptyChannelError.unminifiable_name) {
                // Skip the channel if it's empty
                continue;
            }
            else {
                throw error; // Re-throw the error if it's not an EmptyChannelError
            }
        }
    }
}
function* mapDebugTasks(step, tasks) {
    const ts = new Date().toISOString();
    for (const { name, input, config, triggers } of tasks) {
        if (config?.tags?.includes(constants_js_1.TAG_HIDDEN))
            continue;
        const metadata = { ...config?.metadata };
        const idMetadata = (0, utils_js_1._getIdMetadata)({
            langgraph_step: metadata.langgraph_step,
            langgraph_node: metadata.langgraph_node,
            langgraph_triggers: metadata.langgraph_triggers,
            langgraph_task_idx: metadata.langgraph_task_idx,
        });
        yield {
            type: "task",
            timestamp: ts,
            step,
            payload: {
                id: (0, langgraph_checkpoint_1.uuid5)(JSON.stringify([name, step, idMetadata]), constants_js_1.TASK_NAMESPACE),
                name,
                input,
                triggers,
            },
        };
    }
}
exports.mapDebugTasks = mapDebugTasks;
function* mapDebugTaskResults(step, tasks, streamChannelsList) {
    const ts = new Date().toISOString();
    for (const { name, writes, config } of tasks) {
        if (config?.tags?.includes(constants_js_1.TAG_HIDDEN))
            continue;
        const metadata = { ...config?.metadata };
        const idMetadata = (0, utils_js_1._getIdMetadata)(metadata);
        yield {
            type: "task_result",
            timestamp: ts,
            step,
            payload: {
                id: (0, langgraph_checkpoint_1.uuid5)(JSON.stringify([name, step, idMetadata]), constants_js_1.TASK_NAMESPACE),
                name,
                result: writes.filter(([channel]) => streamChannelsList.includes(channel)),
            },
        };
    }
}
exports.mapDebugTaskResults = mapDebugTaskResults;
function* mapDebugCheckpoint(step, config, channels, streamChannels, metadata, tasks, pendingWrites) {
    function formatConfig(config) {
        // make sure the config is consistent with Python
        const pyConfig = {};
        if (config.callbacks != null)
            pyConfig.callbacks = config.callbacks;
        if (config.configurable != null)
            pyConfig.configurable = config.configurable;
        if (config.maxConcurrency != null)
            pyConfig.max_concurrency = config.maxConcurrency;
        if (config.metadata != null)
            pyConfig.metadata = config.metadata;
        if (config.recursionLimit != null)
            pyConfig.recursion_limit = config.recursionLimit;
        if (config.runId != null)
            pyConfig.run_id = config.runId;
        if (config.runName != null)
            pyConfig.run_name = config.runName;
        if (config.tags != null)
            pyConfig.tags = config.tags;
        return pyConfig;
    }
    function getCurrentUTC() {
        const now = new Date();
        return new Date(now.getTime() - now.getTimezoneOffset() * 60 * 1000);
    }
    const ts = getCurrentUTC().toISOString();
    yield {
        type: "checkpoint",
        timestamp: ts,
        step,
        payload: {
            config: formatConfig(config),
            values: (0, io_js_1.readChannels)(channels, streamChannels),
            metadata,
            next: tasks.map((task) => task.name),
            tasks: tasksWithWrites(tasks, pendingWrites),
        },
    };
}
exports.mapDebugCheckpoint = mapDebugCheckpoint;
function tasksWithWrites(tasks, pendingWrites) {
    return tasks.map((task) => {
        const error = pendingWrites.find(([id, n]) => id === task.id && n === constants_js_1.ERROR)?.[2];
        if (error)
            return { id: task.id, name: task.name, error };
        return { id: task.id, name: task.name };
    });
}
exports.tasksWithWrites = tasksWithWrites;
function printStepCheckpoint(step, channels, whitelist) {
    console.log([
        `${wrap(COLORS_MAP.blue, `[${step}:checkpoint]`)}`,
        `\x1b[1m State at the end of step ${step}:\x1b[0m\n`,
        JSON.stringify((0, io_js_1.readChannels)(channels, whitelist), null, 2),
    ].join(""));
}
exports.printStepCheckpoint = printStepCheckpoint;
function printStepTasks(step, nextTasks) {
    const nTasks = nextTasks.length;
    console.log([
        `${wrap(COLORS_MAP.blue, `[${step}:tasks]`)}`,
        `\x1b[1m Starting step ${step} with ${nTasks} task${nTasks === 1 ? "" : "s"}:\x1b[0m\n`,
        nextTasks
            .map((task) => `- ${wrap(COLORS_MAP.green, String(task.name))} -> ${JSON.stringify(task.input, null, 2)}`)
            .join("\n"),
    ].join(""));
}
exports.printStepTasks = printStepTasks;
function printStepWrites(step, writes, whitelist) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const byChannel = {};
    for (const [channel, value] of writes) {
        if (whitelist.includes(channel)) {
            if (!byChannel[channel]) {
                byChannel[channel] = [];
            }
            byChannel[channel].push(value);
        }
    }
    console.log([
        `${wrap(COLORS_MAP.blue, `[${step}:writes]`)}`,
        `\x1b[1m Finished step ${step} with writes to ${Object.keys(byChannel).length} channel${Object.keys(byChannel).length !== 1 ? "s" : ""}:\x1b[0m\n`,
        Object.entries(byChannel)
            .map(([name, vals]) => `- ${wrap(COLORS_MAP.yellow, name)} -> ${vals
            .map((v) => JSON.stringify(v))
            .join(", ")}`)
            .join("\n"),
    ].join(""));
}
exports.printStepWrites = printStepWrites;
