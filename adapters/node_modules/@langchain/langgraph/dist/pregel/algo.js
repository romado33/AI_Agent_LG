/* eslint-disable no-param-reassign */
import { mergeConfigs, patchConfig, } from "@langchain/core/runnables";
import { copyCheckpoint, uuid5, maxChannelVersion, } from "@langchain/langgraph-checkpoint";
import { createCheckpoint, emptyChannels, } from "../channels/base.js";
import { readChannel, readChannels } from "./io.js";
import { _isSend, _isSendInterface, CHECKPOINT_NAMESPACE_SEPARATOR, CONFIG_KEY_CHECKPOINTER, CONFIG_KEY_READ, CONFIG_KEY_RESUMING, CONFIG_KEY_SEND, INTERRUPT, RESERVED, TAG_HIDDEN, TASKS, } from "../constants.js";
import { EmptyChannelError, InvalidUpdateError } from "../errors.js";
import { _getIdMetadata, getNullChannelVersion } from "./utils.js";
export const increment = (current) => {
    return current !== undefined ? current + 1 : 1;
};
export function shouldInterrupt(checkpoint, interruptNodes, tasks) {
    const versionValues = Object.values(checkpoint.channel_versions);
    const versionType = versionValues.length > 0 ? typeof versionValues[0] : undefined;
    let nullVersion;
    if (versionType === "number") {
        nullVersion = 0;
    }
    else if (versionType === "string") {
        nullVersion = "";
    }
    const seen = checkpoint.versions_seen[INTERRUPT] ?? {};
    const anyChannelUpdated = Object.entries(checkpoint.channel_versions).some(([chan, version]) => {
        return version > (seen[chan] ?? nullVersion);
    });
    const anyTriggeredNodeInInterruptNodes = tasks.some((task) => interruptNodes === "*"
        ? !task.config?.tags?.includes(TAG_HIDDEN)
        : interruptNodes.includes(task.name));
    return anyChannelUpdated && anyTriggeredNodeInInterruptNodes;
}
export function _localRead(checkpoint, channels, task, select, fresh = false) {
    if (fresh) {
        const newCheckpoint = createCheckpoint(checkpoint, channels, -1);
        // create a new copy of channels
        const newChannels = emptyChannels(channels, newCheckpoint);
        // Note: _applyWrites contains side effects
        _applyWrites(copyCheckpoint(newCheckpoint), newChannels, [task]);
        return readChannels(newChannels, select);
    }
    else {
        return readChannels(channels, select);
    }
}
export function _localWrite(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
commit, processes, channels, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
writes) {
    for (const [chan, value] of writes) {
        if (chan === TASKS) {
            if (!_isSend(value)) {
                throw new InvalidUpdateError(`Invalid packet type, expected SendProtocol, got ${JSON.stringify(value)}`);
            }
            if (!(value.node in processes)) {
                throw new InvalidUpdateError(`Invalid node name ${value.node} in packet`);
            }
        }
        else if (!(chan in channels)) {
            console.warn(`Skipping write for channel '${chan}' which has no readers`);
        }
    }
    commit(writes);
}
export function _applyWrites(checkpoint, channels, tasks, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
getNextVersion) {
    // Update seen versions
    for (const task of tasks) {
        if (checkpoint.versions_seen[task.name] === undefined) {
            checkpoint.versions_seen[task.name] = {};
        }
        for (const chan of task.triggers) {
            if (chan in checkpoint.channel_versions) {
                checkpoint.versions_seen[task.name][chan] =
                    checkpoint.channel_versions[chan];
            }
        }
    }
    // Find the highest version of all channels
    let maxVersion;
    if (Object.keys(checkpoint.channel_versions).length > 0) {
        maxVersion = maxChannelVersion(...Object.values(checkpoint.channel_versions));
    }
    // Consume all channels that were read
    const channelsToConsume = new Set(tasks
        .flatMap((task) => task.triggers)
        .filter((chan) => !RESERVED.includes(chan)));
    for (const chan of channelsToConsume) {
        if (channels[chan].consume()) {
            if (getNextVersion !== undefined) {
                checkpoint.channel_versions[chan] = getNextVersion(maxVersion, channels[chan]);
            }
        }
    }
    // Clear pending sends
    if (checkpoint.pending_sends) {
        checkpoint.pending_sends = [];
    }
    // Group writes by channel
    const pendingWriteValuesByChannel = {};
    for (const task of tasks) {
        for (const [chan, val] of task.writes) {
            if (chan === TASKS) {
                checkpoint.pending_sends.push({
                    node: val.node,
                    args: val.args,
                });
            }
            else {
                if (chan in pendingWriteValuesByChannel) {
                    pendingWriteValuesByChannel[chan].push(val);
                }
                else {
                    pendingWriteValuesByChannel[chan] = [val];
                }
            }
        }
    }
    // find the highest version of all channels
    maxVersion = undefined;
    if (Object.keys(checkpoint.channel_versions).length > 0) {
        maxVersion = maxChannelVersion(...Object.values(checkpoint.channel_versions));
    }
    const updatedChannels = new Set();
    // Apply writes to channels
    for (const [chan, vals] of Object.entries(pendingWriteValuesByChannel)) {
        if (chan in channels) {
            let updated;
            try {
                updated = channels[chan].update(vals);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (e) {
                if (e.name === InvalidUpdateError.unminifiable_name) {
                    throw new InvalidUpdateError(`Invalid update for channel ${chan} with values ${JSON.stringify(vals)}`);
                }
                else {
                    throw e;
                }
            }
            if (updated && getNextVersion !== undefined) {
                checkpoint.channel_versions[chan] = getNextVersion(maxVersion, channels[chan]);
            }
            updatedChannels.add(chan);
        }
    }
    // Channels that weren't updated in this step are notified of a new step
    for (const chan of Object.keys(channels)) {
        if (!updatedChannels.has(chan)) {
            const updated = channels[chan].update([]);
            if (updated && getNextVersion !== undefined) {
                checkpoint.channel_versions[chan] = getNextVersion(maxVersion, channels[chan]);
            }
        }
    }
}
export function _prepareNextTasks(checkpoint, processes, channels, config, forExecution, extra) {
    const parentNamespace = config.configurable?.checkpoint_ns ?? "";
    const tasks = [];
    const taskDescriptions = [];
    const { step, isResuming = false, checkpointer, manager } = extra;
    for (const packet of checkpoint.pending_sends) {
        if (!_isSendInterface(packet)) {
            console.warn(`Ignoring invalid packet ${JSON.stringify(packet)} in pending sends.`);
            continue;
        }
        if (!(packet.node in processes)) {
            console.warn(`Ignoring unknown node name ${packet.node} in pending sends.`);
            continue;
        }
        const triggers = [TASKS];
        const metadata = _getIdMetadata({
            langgraph_step: step,
            langgraph_node: packet.node,
            langgraph_triggers: triggers,
            langgraph_task_idx: forExecution ? tasks.length : taskDescriptions.length,
        });
        const checkpointNamespace = parentNamespace === ""
            ? packet.node
            : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${packet.node}`;
        const taskId = uuid5(JSON.stringify([checkpointNamespace, metadata]), checkpoint.id);
        if (forExecution) {
            const proc = processes[packet.node];
            const node = proc.getNode();
            if (node !== undefined) {
                const writes = [];
                tasks.push({
                    name: packet.node,
                    input: packet.args,
                    proc: node,
                    writes,
                    triggers,
                    config: patchConfig(mergeConfigs(config, processes[packet.node].config, {
                        metadata,
                    }), {
                        runName: packet.node,
                        callbacks: manager?.getChild(`graph:step:${step}`),
                        configurable: {
                            [CONFIG_KEY_SEND]: _localWrite.bind(undefined, (items) => writes.push(...items), processes, channels),
                            [CONFIG_KEY_READ]: _localRead.bind(undefined, checkpoint, channels, {
                                name: packet.node,
                                writes: writes,
                                triggers,
                            }),
                        },
                    }),
                    id: taskId,
                    retry_policy: proc.retryPolicy,
                });
            }
        }
        else {
            taskDescriptions.push({ id: taskId, name: packet.node });
        }
    }
    // Check if any processes should be run in next step
    // If so, prepare the values to be passed to them
    const nullVersion = getNullChannelVersion(checkpoint.channel_versions);
    if (nullVersion === undefined) {
        return forExecution ? tasks : taskDescriptions;
    }
    for (const [name, proc] of Object.entries(processes)) {
        const seen = checkpoint.versions_seen[name] ?? {};
        const triggers = proc.triggers
            .filter((chan) => {
            const result = readChannel(channels, chan, false, true);
            const isEmptyChannelError = 
            // eslint-disable-next-line no-instanceof/no-instanceof
            result instanceof Error &&
                result.name === EmptyChannelError.unminifiable_name;
            return (!isEmptyChannelError &&
                (checkpoint.channel_versions[chan] ?? nullVersion) >
                    (seen[chan] ?? nullVersion));
        })
            .sort();
        // If any of the channels read by this process were updated
        if (triggers.length > 0) {
            const val = _procInput(proc, channels, forExecution);
            if (val === undefined) {
                continue;
            }
            const metadata = _getIdMetadata({
                langgraph_step: step,
                langgraph_node: name,
                langgraph_triggers: triggers,
                langgraph_task_idx: forExecution
                    ? tasks.length
                    : taskDescriptions.length,
            });
            const checkpointNamespace = parentNamespace === ""
                ? name
                : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;
            const taskId = uuid5(JSON.stringify([checkpointNamespace, metadata]), checkpoint.id);
            if (forExecution) {
                const node = proc.getNode();
                if (node !== undefined) {
                    const writes = [];
                    tasks.push({
                        name,
                        input: val,
                        proc: node,
                        writes,
                        triggers,
                        config: patchConfig(mergeConfigs(config, proc.config, { metadata }), {
                            runName: name,
                            callbacks: manager?.getChild(`graph:step:${step}`),
                            configurable: {
                                [CONFIG_KEY_SEND]: _localWrite.bind(undefined, (items) => writes.push(...items), processes, channels),
                                [CONFIG_KEY_READ]: _localRead.bind(undefined, checkpoint, channels, {
                                    name,
                                    writes: writes,
                                    triggers,
                                }),
                                [CONFIG_KEY_CHECKPOINTER]: checkpointer,
                                [CONFIG_KEY_RESUMING]: isResuming,
                                checkpoint_id: checkpoint.id,
                                checkpoint_ns: checkpointNamespace,
                            },
                        }),
                        id: taskId,
                        retry_policy: proc.retryPolicy,
                    });
                }
            }
            else {
                taskDescriptions.push({ id: taskId, name });
            }
        }
    }
    return forExecution ? tasks : taskDescriptions;
}
function _procInput(proc, channels, forExecution) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let val;
    // If all trigger channels subscribed by this process are not empty
    // then invoke the process with the values of all non-empty channels
    if (Array.isArray(proc.channels)) {
        let successfulRead = false;
        for (const chan of proc.channels) {
            try {
                val = readChannel(channels, chan, false);
                successfulRead = true;
                break;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (e) {
                if (e.name === EmptyChannelError.unminifiable_name) {
                    continue;
                }
                else {
                    throw e;
                }
            }
        }
        if (!successfulRead) {
            return;
        }
    }
    else if (typeof proc.channels === "object") {
        val = {};
        try {
            for (const [k, chan] of Object.entries(proc.channels)) {
                val[k] = readChannel(channels, chan, !proc.triggers.includes(chan));
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (e) {
            if (e.name === EmptyChannelError.unminifiable_name) {
                return;
            }
            else {
                throw e;
            }
        }
    }
    else {
        throw new Error(`Invalid channels type, expected list or dict, got ${proc.channels}`);
    }
    // If the process has a mapper, apply it to the value
    if (forExecution && proc.mapper !== undefined) {
        val = proc.mapper(val);
    }
    return val;
}
