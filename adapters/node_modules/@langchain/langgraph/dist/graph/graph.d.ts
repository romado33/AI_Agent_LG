import { Runnable, RunnableConfig, RunnableLike } from "@langchain/core/runnables";
import { Graph as RunnableGraph } from "@langchain/core/runnables/graph";
import { BaseCheckpointSaver } from "@langchain/langgraph-checkpoint";
import { PregelNode } from "../pregel/read.js";
import { Pregel } from "../pregel/index.js";
import type { PregelParams } from "../pregel/types.js";
import { BaseChannel } from "../channels/base.js";
import { All } from "../pregel/types.js";
import { Send } from "../constants.js";
import { RunnableCallable } from "../utils.js";
/** Special reserved node name denoting the start of a graph. */
export declare const START = "__start__";
/** Special reserved node name denoting the end of a graph. */
export declare const END = "__end__";
export interface BranchOptions<IO, N extends string> {
    source: N;
    path: Branch<IO, N>["condition"];
    pathMap?: Record<string, N | typeof END> | (N | typeof END)[];
}
export declare class Branch<IO, N extends string> {
    condition: (input: IO, config?: RunnableConfig) => string | Send | (string | Send)[] | Promise<string | Send | (string | Send)[]>;
    ends?: Record<string, N | typeof END>;
    constructor(options: Omit<BranchOptions<IO, N>, "source">);
    compile(writer: (dests: (string | Send)[]) => Runnable | undefined, reader?: (config: RunnableConfig) => IO): RunnableCallable<unknown, unknown>;
    _route(input: IO, config: RunnableConfig, writer: (dests: (string | Send)[]) => Runnable | undefined, reader?: (config: RunnableConfig) => IO): Promise<Runnable | undefined>;
}
export type NodeSpec<RunInput, RunOutput> = {
    runnable: Runnable<RunInput, RunOutput>;
    metadata?: Record<string, unknown>;
};
export type AddNodeOptions = {
    metadata?: Record<string, unknown>;
};
export declare class Graph<N extends string = typeof END, RunInput = any, RunOutput = any, NodeSpecType extends NodeSpec<RunInput, RunOutput> = NodeSpec<RunInput, RunOutput>> {
    nodes: Record<N, NodeSpecType>;
    edges: Set<[N | typeof START, N | typeof END]>;
    branches: Record<string, Record<string, Branch<RunInput, N>>>;
    entryPoint?: string;
    compiled: boolean;
    supportMultipleEdges: boolean;
    constructor();
    protected warnIfCompiled(message: string): void;
    get allEdges(): Set<[string, string]>;
    addNode<K extends string, NodeInput = RunInput>(key: K, action: RunnableLike<NodeInput, RunOutput>, options?: AddNodeOptions): Graph<N | K, RunInput, RunOutput>;
    addEdge(startKey: N | typeof START, endKey: N | typeof END): this;
    addConditionalEdges(source: BranchOptions<RunInput, N>): this;
    addConditionalEdges(source: N, path: Branch<RunInput, N>["condition"], pathMap?: BranchOptions<RunInput, N>["pathMap"]): this;
    /**
     * @deprecated use `addEdge(START, key)` instead
     */
    setEntryPoint(key: N): this;
    /**
     * @deprecated use `addEdge(key, END)` instead
     */
    setFinishPoint(key: N): this;
    compile({ checkpointer, interruptBefore, interruptAfter, }?: {
        checkpointer?: BaseCheckpointSaver;
        interruptBefore?: N[] | All;
        interruptAfter?: N[] | All;
    }): CompiledGraph<N>;
    validate(interrupt?: string[]): void;
}
export declare class CompiledGraph<N extends string, RunInput = any, RunOutput = any> extends Pregel<Record<N | typeof START, PregelNode<RunInput, RunOutput>>, Record<N | typeof START | typeof END | string, BaseChannel>> {
    NodeType: N;
    RunInput: RunInput;
    RunOutput: RunOutput;
    builder: Graph<N, RunInput, RunOutput>;
    constructor({ builder, ...rest }: {
        builder: Graph<N, RunInput, RunOutput>;
    } & PregelParams<Record<N | typeof START, PregelNode<RunInput, RunOutput>>, Record<N | typeof START | typeof END | string, BaseChannel>>);
    attachNode(key: N, node: NodeSpec<RunInput, RunOutput>): void;
    attachEdge(start: N | typeof START, end: N | typeof END): void;
    attachBranch(start: N | typeof START, name: string, branch: Branch<RunInput, N>): void;
    /**
     * Returns a drawable representation of the computation graph.
     */
    getGraph(config?: RunnableConfig & {
        xray?: boolean | number;
    }): RunnableGraph;
}
